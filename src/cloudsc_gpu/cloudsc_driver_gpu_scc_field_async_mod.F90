! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC_MOD

  USE PARKIND1, ONLY: JPIM, JPRB
  USE YOMPHYDER, ONLY: STATE_TYPE
  USE YOECLDP, ONLY : NCLV, YRECLDP, TECLDP
  USE CLOUDSC_MPI_MOD, ONLY: NUMPROC, IRANK
  USE TIMER_MOD, ONLY : PERFORMANCE_TIMER, GET_THREAD_NUM

  USE CLOUDSC_GPU_SCC_MOD, ONLY: CLOUDSC_SCC
  USE CLOUDSC_AUX_TYPE_MOD, ONLY: CLOUDSC_AUX_TYPE
  USE CLOUDSC_FLUX_TYPE_MOD, ONLY: CLOUDSC_FLUX_TYPE
  USE CLOUDSC_STATE_TYPE_MOD, ONLY: CLOUDSC_STATE_TYPE

  USE FIELD_ASYNC_MODULE, ONLY: WAIT_FOR_ASYNC_QUEUE

  IMPLICIT NONE

CONTAINS

  SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC( &
     & NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG, KFLDX, PTSPHY, &
     & AUX, FLUX, TENDENCY_TMP, TENDENCY_LOC, BLOCKING_CHUNK_SIZE, NQUEUES)

    ! Driver routine that invokes the optimized CLAW-based CLOUDSC GPU kernel

    INTEGER(KIND=JPIM)                                    :: NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG
    INTEGER(KIND=JPIM)                                    :: KFLDX
    REAL(KIND=JPRB)                                       :: PTSPHY       ! Physics timestep
    TYPE(CLOUDSC_AUX_TYPE),   INTENT(INOUT)               :: AUX
    TYPE(CLOUDSC_FLUX_TYPE),  INTENT(INOUT)               :: FLUX
    TYPE(CLOUDSC_STATE_TYPE), INTENT(INOUT)               :: TENDENCY_LOC, TENDENCY_TMP
    INTEGER(KIND=JPIM), INTENT(IN)                        :: BLOCKING_CHUNK_SIZE
    INTEGER(KIND=JPIM), INTENT(IN)                        :: NQUEUES

    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PT(:,:,:)       ! T at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PQ(:,:,:)       ! Q at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFA(:,:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFL(:,:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVFI(:,:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNA(:,:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNL(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PDYNI(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PHRSW(:,:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PHRLW(:,:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PVERVEL(:,:,:)  ! Vertical velocity
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PAP(:,:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PAPH(:,:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLSM(:,:)       ! Land fraction (0-1)
    LOGICAL, POINTER, CONTIGUOUS          :: LDCUM(:,:)      ! Convection active
    INTEGER(KIND=JPIM),POINTER, CONTIGUOUS:: KTYPE(:,:)      ! Convection type 0,1,2
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLU(:,:,:)      ! Conv. condensate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLUDE(:,:,:)    ! Conv. detrained water
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PSNDE(:,:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PMFU(:,:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PMFD(:,:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PA(:,:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCLV(:,:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PSUPSAT(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PLCRIT_AER(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PICRIT_AER(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PRE_ICE(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCCN(:,:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PNICE(:,:,:)    ! ice number concentration (cf. CCN)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PCOVPTOT(:,:,:)    ! Precip fraction
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PRAINFRAC_TOPRFZ(:,:)
    ! Flux diagnostics for DDH budget
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQLF(:,:,:)    ! Flux of liquid
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQIF(:,:,:)    ! Flux of ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQLNG(:,:,:)   ! -ve corr for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQNNG(:,:,:)   ! -ve corr for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQRF(:,:,:)    ! Flux diagnostics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQSF(:,:,:)    !    for DDH, generic
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQRNG(:,:,:)   ! rain
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFCQSNG(:,:,:)   ! snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQLTUR(:,:,:)  ! liquid flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFSQITUR(:,:,:)  ! ice flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFPLSL(:,:,:)    ! liq+rain sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFPLSN(:,:,:)    ! ice+snow sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFHPSL(:,:,:)    ! Enthalpy flux for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: PFHPSN(:,:,:)    ! ice number concentration (cf. CCN)

    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_LOC_T(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_LOC_Q(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_LOC_A(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_LOC_CLD(:,:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_TMP_T(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_TMP_Q(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_TMP_A(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS  :: TEND_TMP_CLD(:,:,:,:)

    INTEGER(KIND=JPIM) :: JKGLO,IBL,ICEND
    TYPE(PERFORMANCE_TIMER) :: TIMER
    INTEGER(KIND=JPIM) :: TID ! thread id from 0 .. NUMOMP - 1

    ! Local copy of cloud parameters for offload
    TYPE(TECLDP) :: LOCAL_YRECLDP

     ! double blocking variables
    INTEGER(KIND=JPIM) :: QUEUE
    INTEGER(KIND=JPIM) :: OFFSET
    INTEGER(KIND=JPIM) :: CHUNK_SIZE            ! chunk size
    INTEGER(KIND=JPIM) :: CHUNK_COUNT           ! number of chunks
    INTEGER(KIND=JPIM) :: CHUNK_IDX             ! idx of current chunk in [1,CHUNK_COUNT]
    INTEGER(KIND=JPIM) :: BLOCK_START           ! start block of current chunk in [1,NGPBLKS]
    INTEGER(KIND=JPIM) :: BLOCK_END             ! end block of current chunk in [1,NGPBLKS]
    INTEGER(KIND=JPIM) :: IBLLOC                ! local loop idx inside inner block loop
    INTEGER(KIND=JPIM) :: BLK_BOUNDS(2)         ! Array holding BLOCK_START and BLOCK_END

    NGPBLKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
1003 format(5x,'NUMPROC=',i0,', NUMOMP=',i0,', NGPTOTG=',i0,', NPROMA=',i0,', NGPBLKS=',i0)
    if (irank == 0) then
      write(0,1003) NUMPROC,NUMOMP,NGPTOTG,NPROMA,NGPBLKS
    end if

    ! Global timer for the parallel region
    CALL TIMER%START(NUMOMP)
    ! Thread timer that measures the total time for kernel + data transfers, as
    ! opposed to other gpu variants, where this only measures the kernel time.
    TID = GET_THREAD_NUM()
    CALL TIMER%THREAD_START(TID)

    ! Workaround for PGI / OpenACC oddities:
    ! Create a local copy of the parameter struct to ensure they get
    ! moved to the device the in ``acc data`` clause below
    LOCAL_YRECLDP = YRECLDP
    !$acc enter data copyin(LOCAL_YRECLDP)

    CHUNK_SIZE = MIN(BLOCKING_CHUNK_SIZE,NGPBLKS)
    CHUNK_COUNT=(NGPBLKS+CHUNK_SIZE-1)/CHUNK_SIZE

    ! Allocate NQUEUES*CHUNK_SIZE on device for each field on the device
    CALL AUX%F_PT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PQ%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PVFA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PVFL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PVFI%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PDYNA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PDYNL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PDYNI%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PHRSW%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PHRLW%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PVERVEL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PAP%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PLU%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PSNDE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PMFU%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PMFD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PSUPSAT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PLCRIT_AER%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PICRIT_AER%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PRE_ICE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PCCN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PNICE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])

    CALL AUX%F_PAPH%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PLSM%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_LDCUM%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_KTYPE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PCLV%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])

    CALL TENDENCY_TMP%F_T%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_TMP%F_Q%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_TMP%F_A%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_TMP%F_CLD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])

    CALL AUX%F_PLUDE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PCOVPTOT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL AUX%F_PRAINFRAC_TOPRFZ%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])

    CALL FLUX%F_PFSQLF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFSQIF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFCQLNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFCQNNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFSQRF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFSQSF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFCQRNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFCQSNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFSQLTUR%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFSQITUR%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFPLSL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFPLSN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFHPSL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL FLUX%F_PFHPSN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])

    CALL TENDENCY_LOC%F_T%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_LOC%F_Q%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_LOC%F_A%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])
    CALL TENDENCY_LOC%F_CLD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*CHUNK_SIZE])


    DO CHUNK_IDX=1, CHUNK_COUNT
      BLOCK_START=(CHUNK_IDX-1)*CHUNK_SIZE+1
      BLOCK_END=MIN((CHUNK_IDX)*CHUNK_SIZE, NGPBLKS)
      BLK_BOUNDS=[BLOCK_START, BLOCK_END]
      QUEUE = MODULO(CHUNK_IDX,NQUEUES)+1
      OFFSET = (QUEUE-1)*CHUNK_SIZE

      ! partial async offload of fields to device
      CALL AUX%F_PT%GET_DEVICE_DATA_FORCE(PT, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PQ%GET_DEVICE_DATA_FORCE(PQ, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFA%GET_DEVICE_DATA_FORCE(PVFA, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFL%GET_DEVICE_DATA_FORCE(PVFL, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFI%GET_DEVICE_DATA_FORCE(PVFI, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNA%GET_DEVICE_DATA_FORCE(PDYNA, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNL%GET_DEVICE_DATA_FORCE(PDYNL, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNI%GET_DEVICE_DATA_FORCE(PDYNI, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PHRSW%GET_DEVICE_DATA_FORCE(PHRSW, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PHRLW%GET_DEVICE_DATA_FORCE(PHRLW, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVERVEL%GET_DEVICE_DATA_FORCE(PVERVEL, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PAP%GET_DEVICE_DATA_FORCE(PAP, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLU%GET_DEVICE_DATA_FORCE(PLU, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PSNDE%GET_DEVICE_DATA_FORCE(PSNDE, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PMFU%GET_DEVICE_DATA_FORCE(PMFU, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PMFD%GET_DEVICE_DATA_FORCE(PMFD, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PA%GET_DEVICE_DATA_FORCE(PA, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PSUPSAT%GET_DEVICE_DATA_FORCE(PSUPSAT, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLCRIT_AER%GET_DEVICE_DATA_FORCE(PLCRIT_AER, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PICRIT_AER%GET_DEVICE_DATA_FORCE(PICRIT_AER, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRE_ICE%GET_DEVICE_DATA_FORCE(PRE_ICE, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCCN%GET_DEVICE_DATA_FORCE(PCCN, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PNICE%GET_DEVICE_DATA_FORCE(PNICE, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL AUX%F_PAPH%GET_DEVICE_DATA_FORCE(PAPH, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLSM%GET_DEVICE_DATA_FORCE(PLSM, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_LDCUM%GET_DEVICE_DATA_FORCE(LDCUM, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_KTYPE%GET_DEVICE_DATA_FORCE(KTYPE, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCLV%GET_DEVICE_DATA_FORCE(PCLV, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL TENDENCY_TMP%F_T%GET_DEVICE_DATA_FORCE(TEND_TMP_T, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_Q%GET_DEVICE_DATA_FORCE(TEND_TMP_Q, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_A%GET_DEVICE_DATA_FORCE(TEND_TMP_A, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_CLD%GET_DEVICE_DATA_FORCE(TEND_TMP_CLD, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL AUX%F_PLUDE%GET_DEVICE_DATA_FORCE(PLUDE, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCOVPTOT%GET_DEVICE_DATA_FORCE(PCOVPTOT, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRAINFRAC_TOPRFZ%GET_DEVICE_DATA_FORCE(PRAINFRAC_TOPRFZ, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL FLUX%F_PFSQLF%GET_DEVICE_DATA_FORCE(PFSQLF, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQIF%GET_DEVICE_DATA_FORCE(PFSQIF, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQLNG%GET_DEVICE_DATA_FORCE(PFCQLNG, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQNNG%GET_DEVICE_DATA_FORCE(PFCQNNG, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQRF%GET_DEVICE_DATA_FORCE(PFSQRF, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQSF%GET_DEVICE_DATA_FORCE(PFSQSF, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQRNG%GET_DEVICE_DATA_FORCE(PFCQRNG, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQSNG%GET_DEVICE_DATA_FORCE(PFCQSNG, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLTUR%GET_DEVICE_DATA_FORCE(PFSQLTUR, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQITUR%GET_DEVICE_DATA_FORCE(PFSQITUR, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSL%GET_DEVICE_DATA_FORCE(PFPLSL, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSN%GET_DEVICE_DATA_FORCE(PFPLSN, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSL%GET_DEVICE_DATA_FORCE(PFHPSL, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSN%GET_DEVICE_DATA_FORCE(PFHPSN, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL TENDENCY_LOC%F_T%GET_DEVICE_DATA_FORCE(TEND_LOC_T, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_Q%GET_DEVICE_DATA_FORCE(TEND_LOC_Q, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_A%GET_DEVICE_DATA_FORCE(TEND_LOC_A, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_CLD%GET_DEVICE_DATA_FORCE(TEND_LOC_CLD, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)


!$acc parallel loop gang vector_length(NPROMA) &
#ifndef FIELD_API_DISABLE_MAPPED_MEMORY
!$acc & present(LOCAL_YRECLDP, &
#else
!$acc & present(LOCAL_YRECLDP) deviceptr( &
#endif
!$acc & PT, PQ,TEND_TMP_T,TEND_TMP_Q,&
!$acc & TEND_TMP_A, TEND_TMP_CLD, TEND_LOC_T, TEND_LOC_Q, &
!$acc & TEND_LOC_A, TEND_LOC_CLD, PVFA, PVFL, PVFI, &
!$acc & PDYNA, PDYNL, PDYNI, PHRSW,    PHRLW,&
!$acc & PVERVEL,  PAP,      PAPH,&
!$acc & PLSM,       LDCUM,      KTYPE, &
!$acc & PLU,      PLUDE,    PSNDE,    PMFU,     PMFD,&
!$acc & PA,       PCLV,   PSUPSAT,&
!$acc & PLCRIT_AER,PICRIT_AER,&
!$acc & PRE_ICE, PCCN,     PNICE,&
!$acc & PCOVPTOT, PRAINFRAC_TOPRFZ,&
!$acc & PFSQLF,   PFSQIF ,  PFCQNNG,  PFCQLNG,&
!$acc & PFSQRF,   PFSQSF ,  PFCQRNG,  PFCQSNG,&
!$acc & PFSQLTUR, PFSQITUR , &
!$acc & PFPLSL,   PFPLSN,   PFHPSL,   PFHPSN) &
!$acc & async(QUEUE)
      DO IBL=BLOCK_START,BLOCK_END
        JKGLO=(IBL-1)*NPROMA+1
        ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)

         CALL CLOUDSC_SCC &
          & (1, ICEND, NPROMA, NLEV, PTSPHY,&
          & PT(:,:,IBL), PQ(:,:,IBL), &
          & TEND_TMP_T(:,:,IBL), TEND_TMP_Q(:,:,IBL), TEND_TMP_A(:,:,IBL), TEND_TMP_CLD(:,:,:,IBL), &
          & TEND_LOC_T(:,:,IBL), TEND_LOC_Q(:,:,IBL), TEND_LOC_A(:,:,IBL), TEND_LOC_CLD(:,:,:,IBL), &
          & PVFA(:,:,IBL), PVFL(:,:,IBL), PVFI(:,:,IBL), PDYNA(:,:,IBL), PDYNL(:,:,IBL), PDYNI(:,:,IBL), &
          & PHRSW(:,:,IBL),    PHRLW(:,:,IBL),&
          & PVERVEL(:,:,IBL),  PAP(:,:,IBL),      PAPH(:,:,IBL),&
          & PLSM(:,IBL),       LDCUM(:,IBL),      KTYPE(:,IBL), &
          & PLU(:,:,IBL),      PLUDE(:,:,IBL),    PSNDE(:,:,IBL),    PMFU(:,:,IBL),     PMFD(:,:,IBL),&
          !---prognostic fields
          & PA(:,:,IBL),       PCLV(:,:,:,IBL),   PSUPSAT(:,:,IBL),&
          !-- arrays for aerosol-cloud interactions
          & PLCRIT_AER(:,:,IBL),PICRIT_AER(:,:,IBL),&
          & PRE_ICE(:,:,IBL),&
          & PCCN(:,:,IBL),     PNICE(:,:,IBL),&
          !---diagnostic output
          & PCOVPTOT(:,:,IBL), PRAINFRAC_TOPRFZ(:,IBL),&
          !---resulting fluxes
          & PFSQLF(:,:,IBL),   PFSQIF (:,:,IBL),  PFCQNNG(:,:,IBL),  PFCQLNG(:,:,IBL),&
          & PFSQRF(:,:,IBL),   PFSQSF (:,:,IBL),  PFCQRNG(:,:,IBL),  PFCQSNG(:,:,IBL),&
          & PFSQLTUR(:,:,IBL), PFSQITUR (:,:,IBL), &
          & PFPLSL(:,:,IBL),   PFPLSN(:,:,IBL),   PFHPSL(:,:,IBL),   PFHPSN(:,:,IBL),&
          & YRECLDP=LOCAL_YRECLDP)

      ENDDO
!$acc end parallel loop


      CALL AUX%F_PLUDE%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCOVPTOT%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRAINFRAC_TOPRFZ%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQIF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQLNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQNNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQRF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQSF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQRNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQSNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLTUR%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQITUR%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSL%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSN%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSL%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSN%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_T%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_Q%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_A%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_CLD%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

    END DO ! End of block loop

! Wait for async work in all queues to finish
DO QUEUE=1,NQUEUES
  CALL WAIT_FOR_ASYNC_QUEUE(QUEUE)
END DO

!$acc exit data delete(local_yrecldp)

    CALL TIMER%THREAD_END(TID)
    CALL TIMER%END()

    ! On GPUs, adding block-level column totals is cumbersome and
    ! error prone, and of little value due to the large number of
    ! processing "thread teams". Instead we register the total here.
    CALL TIMER%THREAD_LOG(TID=TID, IGPC=NGPTOT)

    CALL TIMER%PRINT_PERFORMANCE(NPROMA, NGPBLKS, NGPTOT)

  END SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC

END MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC_MOD
